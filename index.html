<html>
<head>
<script src="https://unpkg.com/regression@2.0.1/dist/regression.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"></script>
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/df-number-format/2.1.6/jquery.number.min.js"></script>
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet"/>
<style type=text/css>
.dash { font-size:18px; font-weight:bold; color:#007bff; display:inline-block; border:solid 2px gray; padding:10px; margin: 5px; }
.dash div { color: black; font-weight:normal; }
.sm { opacity:0.6; }
.btn-xs { padding: .25rem .4rem; font-size: .875rem; line-height: .5; border-radius: .2rem; }
</style>
<!--<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/sweetalert/2.1.2/sweetalert.min.js"></script>
<script src="genetic/genetic.js"></script>
<body>
<div class="container body-content">
<h1 style=font-size:50px;text-align:center;font-weight:normal>Predicting COVID-19 <span class=sm id=date></span></h1>
<div class="alert alert-info">
We apply mathematical model to real-time COVID statistics. Using this model, we project data into future and report 1) when function peaks 2) when it returns back to zero 3) what is the area under curve. Prediction improves every day, as new data appear.
<p style=text-align:right;margin-bottom:0>
  <a class="btn btn-primary btn-xs" href=# onclick="$('.collapse.show').removeClass('show').addClass('tmp');$('.collapse:not(.tmp)').addClass('show');$('.collapse.tmp').removeClass('tmp')"> Details </a>
</p>
<div class="collapse" id="collapseExample">
We model epidemic growth as <a href="https://en.wikipedia.org/wiki/Gompertz_function">gomperts function</a>. Precisely, we fit its <a href="https://www.geogebra.org/graphing/svpu7zdd">derivative</a> to reported cases. We then try to extrapolate beyond existing data. All processing is client-side. For curve fitting, we use <a href="https://github.com/subprotocol/genetic-js">genetic.js</a>. Data is being sourced from <a href="https://ourworldindata.org/coronavirus">ourworldindata.org</a>.
</div>
</div>
<table width=100% class=auto-height><tr><td valign=top>
<input autocomplete=off id=search onfocus="$(this).val('');$('#menu a').show()" class="form-control" placeholder=Search />
<div class="list-group auto-height" id=menu style=height:400px;overflow-y:scroll></div></td><td valign=top>
<div>
<canvas id="scratch" style="width: 800px; height: 500px; cursor: crosshair;"></canvas>
</div>
<div>Known infections on <span id=actual></span>: <span class="badge badge-secondary" id=sum></span></div>
<h1>Prediction for <span id=country></span> </h1>
<div class="progress" style=display:none>
  <div class="progress-bar" role="progressbar" style="width: 25%;" aria-valuenow="25" aria-valuemin="0" aria-valuemax="100">25%</div>
</div>
<div id=figures style=display:none;width:800px>
<!--
<div class=dash>solution<div id=solution></div></div>
<div class=dash>generation<div id=generation></div></div>
<div class=dash>bestfit<div id=bestfit></div></div>
<div class=dash>best / pred<div id=bestfit2></div></div>
<div class=dash>vertexerror<div id=vertexerror></div></div>
<div class=dash>avgbestfit<div id=avgbestfit></div></div>
<div class=dash>errorstdev<div id=errorstdev></div></div>
<div title="" class=dash>Regression Quality<div id=quality></div></div>
<div title="" class=dash>Overall<div id=overall></div></div>
-->
<div title="Predicted timespan, days" class=dash>Peak<div id=peak></div></div>
<div title="Predicted timespan, days" class=dash>End<div id=days></div></div>
<div title="Predicted  number of infection cases" class=dash>Expected Number of Infections<br><small style=margin-top:3px;color:#000;font-size:15px;float:right>confidence: <span id=confidence></span></small><div id=infected></div></div>
</div>
</td></tr></table>
</div>
<footer></footer>
<script>

var graph = new Graph(document.getElementById("scratch"), 60, 10000);

var genetic = Genetic.create();


genetic.formula = {
	main: function (K, B, C, x) { return Math.pow(K, 2) * Math.exp(K * (1 - Math.exp(B * (C - x))) - B * (x - C) - K); },
	integral: function (K, B, C, x) { return (Math.exp(-Math.exp(B * (C - x)) * K) * K)/B; },
	centerPoint: function (K, B, C) { return (B * C - Math.log(1 / K)) / B; },
	startPoint: function (K, B, C) { return (B * C - Math.log(10 / K + 1 / 2000)) / B; },
	// x= (B*C-ln((1)/(500K)))/(B)
	endPoint: function (K, B, C) { return (B * C - Math.log(1 / 500 / K)) / B; },
};

genetic.optimize = Genetic.Optimize.Minimize;
genetic.select1 = Genetic.Select1.Tournament2;
genetic.select2 = Genetic.Select2.FittestRandom;

genetic.seed = function() {
	
	var a = [];
	// create coefficients for polynomial with values between (-0.5, 0.5)
	
	var i;
	for (i=0;i<this.userData["terms"];++i) {
		a.push(Math.random()-0.01);
	}
	
	return [12000,0.15,-15];
};

genetic.scale = [4000, 0.5, 5]

genetic.mutate = function(entity) {
	
	// allow chromosomal drift with this range (-0.05, 0.05)
	
	var i = Math.floor(Math.random()*entity.length);
	var drift = ((Math.random()-0.5)*2)* genetic.scale[i];
	entity[i] += drift;
	
	return entity;
};

genetic.crossover = function(mother, father) {

	// crossover via interpolation
	function lerp(a, b, p) {
		return a + (b-a)*p;
	}
	
	var len = mother.length;
	var i = Math.floor(Math.random()*len);
	var r = Math.random();
	var son = [].concat(father);
	var daughter = [].concat(mother);
	
	son[i] = lerp(father[i], mother[i], r);
	daughter[i] = lerp(mother[i], father[i], r);
	
	return [son, daughter];
};

genetic.evaluate = function(coefficients, x, fn) {
	return fn(coefficients[0], coefficients[1], coefficients[2], x);
}
	
genetic.fitness = function(entity) {
	
	var sumSqErr = 0;
	var vertices = this.userData["vertices"];
	
	var i;
	for (i=0;i<vertices.length;++i) {
		var err = this.evaluate(entity, vertices[i][0], genetic.formula.main) - vertices[i][1];
		sumSqErr += err*err;
	}
	
	return Math.sqrt(sumSqErr);
};


genetic.generation = function(pop, generation, stats) {
};

genetic.notification = function(pop, generation, stats, isFinished) {
	
	function poly(entity) {
		var a = [];
		var i;
		for (i=entity.length-1;i>=0;--i) {
			var buf = entity[i].toPrecision(2);
			if (i > 1)
				buf += "<em><b>x<sup>" + i + "<sup></b></em>";
			else if (i == 1)
				buf += "<em><b>x</b></em>";
				
			a.push(buf);
		}
		return a.join(" + ");
	}
	
	function lerp(a, b, p) {
		return a + (b-a)*p;
	}
	
	if (generation == 0) {
		graph.solutions = [];
	}
	
	$("#solution").html(poly(pop[0].entity));
	$("#generation").html(generation+1);
	var completion = Math.round((generation + 1) / 5) + '%';
	$('.progress-bar').css({width: completion}).html(completion);
	$("#bestfit").html(pop[0].fitness.toPrecision(4))
	
	$("#vertexerror").html((pop[0].fitness/graph.vertices.length).toPrecision(4));

	;
	$("#avgbestfit").html(stats.mean.toPrecision(4));
	$("#errorstdev").html(stats.stdev.toPrecision(4));
	
	
	var last = graph.last||"";
	
	var str = pop[0].entity.join(",");
	if (last != str || isFinished) {
		
		if (last != str) {
			graph.solutions.push(pop[0].entity);
			graph.last = str;
		}

		if (isFinished) {
			var res = graph.solutions.pop();
			res.push(genetic.formula.endPoint.apply(null, res));
			window.solution = {
				points: {
					start:  genetic.formula.startPoint.apply(null, res),
					current: graph.vertices.length - 1,
					peak: genetic.formula.centerPoint.apply(null, res),
					end: res[3]
				},
				total: genetic.formula.integral.apply(null, res)
			}
			zero = moment(dates[0]);
			solution.dates = {
				start: zero.clone().add(solution.points.start, 'days'),
				peak: zero.clone().add(solution.points.peak, 'days'),
				end: zero.clone().add(solution.points.end, 'days')
			}
			$('#days').html(solution.dates.end.fromNow() + ' (' + solution.dates.end.format('DD MMM') + ')');
			$('#peak').html(solution.dates.peak.fromNow() + ' (' + solution.dates.peak.format('DD MMM')+')');
			$('#infected').number(solution.total);
			var empiricQualityGate = 50;
			var observationLength = (solution.points.current - solution.points.start)
			var regressionQuality =  solution.total * observationLength / pop[0].fitness;
			var confidence = (solution.points.current - solution.points.start) / (solution.points.peak - solution.points.start) * observationLength;
			$('#quality').number(regressionQuality, 3);
			$('#confidence').html(confidence < 10 ? '<span class="badge badge-danger">very low</span>': confidence < 100 ? '<span class="badge badge-warning">low</span>' : '<span class="badge badge-success">high</span>');
			var overall = (regressionQuality - empiricQualityGate) * confidence;
			if (overall < 0)
				return graph.refuse('Regression did not converge');
			$('#overall').number(overall, 3);
			//$('.progress').hide();
			$('#figures').show();
			$('.dash').show();
			var lineWidth = 2, strokeStyle = 'rgba(90,0,200,0.5)';
			graph.drawFunction(graph.solutions[graph.solutions.length - 1], strokeStyle, lineWidth, genetic.formula.main);
		}
	}
};




function Graph(canvas, xmax, ymax) {
	this.canvas = document.getElementById("scratch");
	
	this.xmax = xmax;
	this.ymax = ymax;
	
	// canvas dimensions
	this.width = parseInt(canvas.style.width);
	this.height = parseInt(canvas.style.height);

	// retina
	var dpr = window.devicePixelRatio || 1;
	canvas.width = this.width*dpr;
	canvas.height = this.height*dpr;
	this.ctx = canvas.getContext("2d");
	this.ctx.scale(dpr, dpr);
	
	
	this.bound = [0,this.width-1,this.height-1,0];
	
	this.bound[0] += 25;
	this.bound[1] -= 25;
	this.bound[2] -= 25;
	this.bound[3] += 50;
	
	this.vertices = [];
	this.solutions = [];
}

Graph.prototype.drawFunction = function(coefficients, strokeStyle, lineWidth, fn) {
	var ctx = this.ctx;
	ctx.save();
	var bound = this.bound;
	
	//ctx.setLineDash([1, 1]);
	ctx.strokeStyle = strokeStyle;
	var xmax = this.xmax;
	var ymax = this.ymax;
	var xstride = (bound[1]-bound[3])/xmax;
	var ystride = (bound[2]-bound[0])/ymax;
	var inc = 1/xstride;
	
	ctx.lineWidth = lineWidth;
	
	ctx.beginPath();
	var x;
	for (x=0;x<xmax;x+=inc) {
		var cx = x*xstride + bound[3];
		var cy = bound[2] - genetic.evaluate(coefficients, x, fn)*ystride;
		
		if (x == 0) {
			ctx.moveTo(cx, cy);
		} else {
			ctx.lineTo(cx, cy);
		}
	}
	
	ctx.stroke();
	
	ctx.restore();
}

Graph.prototype.draw = function() {
	
	
	var ctx = this.ctx;
	ctx.save();
	var bound = this.bound;
	
	ctx.strokeStyle = "#000";
	ctx.fillStyle = "#000";
	ctx.clearRect(0, 0, this.width, this.height);
	
	var xmax = this.xmax;
	var ymax = this.ymax;
	var xstride = (bound[1]-bound[3])/xmax;
	var ystride = (bound[2]-bound[0])/ymax;
	
	
	var i;

	// x-grid
	//for (i=0;i<=xmax;++i) {
	for (i=0;i<=xmax;i+=Math.floor(xmax/15)) {
		var cx = i*xstride + bound[3];
		var y = bound[2];
		
		ctx.strokeStyle = "#eee";
		ctx.beginPath();
		ctx.moveTo(cx, bound[0]);
		ctx.lineTo(cx, y);
		ctx.stroke();
	}
	
	// y-grid
	//for (i=0;i<=ymax;++i) {
	for (i=0;i<=ymax;i+=Math.floor(ymax/10)) {
		var cx = bound[3];
		var y = bound[2] - i*ystride;
		ctx.beginPath();
		ctx.moveTo(cx, y);
		ctx.lineTo(bound[1], y);
		ctx.stroke();
	}
	
	
	// x/y bars
	ctx.beginPath();
	ctx.strokeStyle = "#bbb";
	ctx.moveTo(bound[3], bound[0]);
	ctx.lineTo(bound[3], bound[2]);
	ctx.lineTo(bound[1], bound[2]);
	ctx.lineWidth = 3;
	ctx.stroke();
	

	ctx.lineWidth = 1;
	var i;
	
	
	// x bars
	ctx.strokeStyle = "#000";
	for (i=0;i<=xmax;i+=Math.floor(xmax/9)) {
		var cx = i*xstride + bound[3];
		var y = bound[2];
		
		ctx.beginPath();
		ctx.moveTo(cx, y);
		ctx.lineTo(cx, y+4);
		ctx.stroke();
		
		ctx.font = "12px sans-serif";
		ctx.textAlign = "center";
		ctx.fillText(dates[i],cx,y+16);
	}
	

	// y bars
	for (i=0;i<=ymax;i+=Math.floor(ymax/10)) {
		var cx = bound[3];
		var y = bound[2] - i*ystride;
		ctx.beginPath();
		ctx.moveTo(cx, y);
		ctx.lineTo(cx-4, y);
		ctx.stroke();
		
		ctx.font = "12px sans-serif";
		ctx.textAlign = "right";
		ctx.fillText(i,cx-8,y+4);
	}
	
		
	ctx.restore();
};

Graph.prototype.drawText = function(msg) {
	var ctx = this.ctx;
	var b = this.bound;
	ctx.font = "30px sans-serif";
	ctx.textAlign = "center";
	ctx.fillStyle = "#ccc";
	ctx.fillText(msg, (b[3]+b[1])/2,(b[2]+b[0])/2);
}



Graph.prototype.drawVertices = function() {
	
	var ctx = this.ctx;
	ctx.save();
	var bound = this.bound;
	
	var xmax = this.xmax;
	var ymax = this.ymax;
	var xstride = (bound[1]-bound[3])/xmax;
	var ystride = (bound[2]-bound[0])/ymax;
	
	var i;
	
	ctx.fillStyle = "#000";
	ctx.strokeStyle = "#fff";
	ctx.lineWidth = 2;
	
	// vertices
	for (i=0;i<this.vertices.length;++i) {
		var cx = this.vertices[i][0]*xstride + bound[3];
		var cy = bound[2] - this.vertices[i][1]*ystride;
		
		ctx.beginPath();
		ctx.arc(cx, cy, 3, 0, 2*Math.PI);
		ctx.fill();
		ctx.stroke();
	}
	
	ctx.restore();
};

</script>
<script type=text/javascript>
$.expr[":"].contains = $.expr.createPseudo(function(arg) {
    return function( elem ) {
        return $(elem).text().toUpperCase().indexOf(arg.toUpperCase()) >= 0;
    };
});
search = function (ev) {
	var str = $(ev.target).val();
	if (str.length < 2) $('#menu a').show();
	$('#menu a').hide();
	$('#menu a:contains(' + str + ')').show();
}
$('#search').on('keyup', search);
$.get('https://cowid.netlify.com/data/new_cases.csv').then(function(csv){
	window.data = csv.split('\n').map(function(s){return s.split(',');});
	window.titles = data.shift();
	window.cases = {};
	window.diff = {};
	dates = [];
	titles.map(function(s){
		cases[s]=[];
		diff[s]=[];
	})
	delete cases.date;
	data.map(function(ls,i){
		ls.map(function (el,j) {
			var title = titles[j];
			if (title == 'date') dates.push(el);
			else cases[title].push(el ? parseInt(el) : 0);
		});
	});
	while (!dates[dates.length - 1])
		dates.pop();
	$('#actual').text(dates[dates.length - 1]);
	$('#date').text(moment().format('MMM Do YYYY'))
	var adjustChina = function() {
		// approximate realistic figure for day 27
		var approx=(cases.China[26]+cases.China[28])/2;
		// total cases before day 27
		var x=0.0; for (i = 0; i < 27;++i) x+=cases.China[i];
		// add day 27
		x += approx;
		cases['China Adjusted'] = [];
		diff['China Adjusted'] = [];
		// distribute surplus proportionally between prior days
		for (i = 0; i < 27;++i) x+=cases['China Adjusted'].push(cases.China[i]+cases.China[i]*cases.China[27]/x);
		// same for day 27
		cases['China Adjusted'].push(approx+approx*cases.China[27]/x);
		// copy the rest
		for (i = 28; i<cases.China.length; ++i) cases['China Adjusted'].push(cases.China[i]);
		for (k in cases) {
			var last = 0;
			for (i = 0; i < cases[k].length; ++i) {
				var cur = cases[k][i];
				diff[k][i] = cur - last;
				last = cur;
			}
		}
		cases.China = cases['China Adjusted'];
		delete cases['China Adjusted'];
	}
	adjustChina();
	graph.refuse = function(msg) {
		$('#sum').parent().show();
		$('#figures').show();
		$('.progress, .dash').hide();
		graph.draw();
		graph.drawVertices();
		graph.drawText(msg);
	}
	var estimate = function(country) {
		$('#country').html(country);
		$('.progress').show();
		$('#figures').hide();
		graph.vertices = cases[country].map(function (c, i) { return [i,c]; });
		var sum = graph.vertices.reduce(function (a,b) { return a + b[1]; }, 0);
		var dataPoints = graph.vertices.reduce(function (a,b) { return a + (b[1] > 0); }, 0);
		$('#sum').number(sum);
		if (sum < 10 || dataPoints < 3)
			return graph.refuse('Insufficient number of observations');
		var ymax = graph.vertices.reduce(function (a,b) { return Math.max(a,b[1]); }, 0) * 2
		var scale = Math.floor(Math.log(ymax) / Math.log(10));
		var factor = Math.pow(10, scale);
		ymax = Math.round(ymax / factor) * factor;
		graph.xmax = graph.vertices.length;
		graph.ymax = Math.max(10, ymax);
		graph.draw();
		graph.drawText(country);
		graph.drawVertices();
		var config = { iterations: 500 , size: 250 , crossover: 0.4 , mutation: 1.0 , skip: 10 };
		var userData = { terms: 3, vertices: graph.vertices };
		genetic.evolve(config, userData);
	}
	var clickFn = function (el, k) {
		return function() {
			el.parent().find('.active').removeClass('active');
			el.addClass('active');
			estimate(k);
		}
	}
	for (k in cases) {
		var el = $('<a class="list-group-item list-group-item-action" href=#>' + k + '</div>');
		el.on('click', clickFn(el,k));
		$('#menu').append(el);
	}
	$('#menu a:contains(China)').click()[0].scrollIntoView();

}).fail(function(){
	swal({icon:'error',content:$('<div>Error getting COVID-19 data from <i>ourworldindata.org</i></div>')[0],title:'Network Error'});
});

var onResize = function () {
    var foot = $('footer').height() + 20;
    $('.auto-height').css('height', function () {
        var off = $(this).offset();
        if (off) {
            var h = $(window).height() - off.top - foot;
            return h + 'px';
        }
    });
}
onResize();
$(window).resize(onResize);
</script>
</body>
</html>
